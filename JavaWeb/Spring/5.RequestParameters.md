# Request Parameters
Client 측에서 request 요청 시에 전달하는 parameter 를 spring Controller 에서 받는 방법을 기술한다.

## URL Query Parameters & Html form tag
- `localhost:8080/test?username=kim`과 같이 url 자체에 encoded 된 parameter 가 전달될 때.
- HTML Form tag를 통해 Http body 영역에 url encoded 형태로 전달될 때.

위 두 경우 동일하게 url encoded 형태로 전달되기 때문에 같은 방식으로 처리할 수 있다.

### Basic
- Parameter를 처리하는 method 목록.
- `@RequestParam("paramName") DataType param` 형식의 인자로 받을 것을 권고.
- 너무 많을 경우에는 `@RequestParam Map<String, String> paramMap` 형식의 인자로 받기.

```java
@Slf4j
@Controller
public class RequestParamController {
    
    // 1. HttpServletRequest 직접 호출
    @RequestMapping("/request-param-v1")
    public void requestParamV1(HttpServletRequest request, HttpServletResponse response) throws IOException {
        String username = request.getParameter("username");
        int age = Integer.parseInt(request.getParameter("age"));
        log.info("username = {}, age = {}", username, age);

        response.getWriter().write("ok");
    }

    // 2. @RequestParam - RECOMMENDED
    @ResponseBody
    @RequestMapping("/request-param-v2")
    public String requestParamV2(
        @RequestParam("username") String username,
        @RequestParam("age") int age
    ) {
        log.info("username = {}, age = {}", username, age);

        return "ok";
    }

    // 3. @RequestParam with out key value
    @ResponseBody
    @RequestMapping("/request-param-v3")
    public String requestParamV3(
        @RequestParam String username,
        @RequestParam int age
    ) {
        log.info("username = {}, age = {}", username, age);

        return "ok";
    }

    // 4. not recommended.
    @ResponseBody
    @RequestMapping("/request-param-v4")
    public String requestParamV4(
        String username,
        int age
    ) {
        log.info("username = {}, age = {}", username, age);

        return "ok";
    }

    // 5. @RequestParam
    @ResponseBody
    @RequestMapping("/request-param-map")
    public String requestParamMap(
        @RequestParam Map<String, String> paramMap
    ) {
        log.info("username = {}, age = {}", paramMap.get("username"), paramMap.get("age"));

        return "ok";
    }
}
```

### required
- 특정 parameter의 필수 조건을 설정하는 방법.

```java
    @ResponseBody
    @RequestMapping("/request-required")
    public String requestParamRquired(
        @RequestParam(value = "username", required = true) String username,  // default
        @RequestParam(value = "age", required = false) Integer age
    ) {
        return "ok";
    }
```


- 단, `username=` 과 같이 빈 문자열이 입력되는 경우 `required=true`에 걸리지 않는다.
- 또한, `age` 값이 int와 같은 primitive type이고 `required=false`인 경우 `null`을 age에 할당하면서 500 internal server error 발생.

### defaultValue
- Parameter의 기본값을 설정하는 방법.
- `required=true`로 명시하여도 `required=false`처럼 동작한다.

```java
    @ResponseBody
    @RequestMapping("/request-default")
    public String requestParam(
        @RequestParam(value = "username", defaultValue = "") String username,
        @RequestParam(value = "age", defaultValue = 0) Integer age,
    ) {
        return "ok";
    }
```

### `@ModelAttribute`
- 아래와 같이 객체 형태로 data 구조를 정의하고, Spring에서 request parameter를 자동으로 처리하도록 할 수 있다.

```java
// HelloData.java
@Data  // lombok 필요.
class HelloData {
    private String username;
    private int age;
}
```

- `@ModelAttribute` annotation을 통해 객체 형태로 parameter를 처리할 수 있다.

```java
    // 1. basic - RECOMMENDED
    @ResponseBody
    @RequestMapping("/model-attribute-v1")
    public String modelAttributeV1(
        @ModelAttribute HelloData helloData
    ) {
        log.info("username = {}, age = {}", helloData.getUsername(), helloData.getAge());

        return "ok";
    }

    // 2. without @ModelAttribute - Not RECOMMENDED
    @ResponseBody
    @RequestMapping("/model-attribute-v2")
    public String modelAttributeV2(
        HelloData helloData
    {
        log.info("username = {}, age = {}", helloData.getUsername(), helloData.getAge());

        return "ok";
    })
```

#### 유의사항
- `String`, `Integer`, `int` 같은 단순한 타입 - `@RequestParam` 으로 처리
- 그외 - `@ModelAttribute` 로 처리
- 단, `argument resolver` 로 지정한 타입은 제외.

</br>

## Http Body message (not URL encoded)
- `application/json`, `test/plain`과 같이 Http body message를 통해서 정보를 전달하는 경우 spring에서 처리하는 방법.

### Simple Text
`text/plain;charset=utf-8` 와 같은 단순 텍스트를 처리하는 방법.

```java
@Controller
@RequestMapping("/request-body")
public class RequestBody {
    
    // 1. HttpServletRequest/Response
    @RequestMapping("/string-v1")
    public String stringV1(HttpServletRequest request, HttpServletResponse response) throws IOException {
        InputStream inputStream = request.getInputStream();
        String messageBody = StreamUtils.copyToString(inputStream);

        log.info("messageBody = {}", messageBody);

        response.getWriter().write("ok");
    }

    // 2. InputStream & Writer
    @RequestMapping("/string-v2")
    public String stringV2(InputStream inputStream, Writer responseWriter) {
        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);
        
        log.info("messageBody = {}", messageBody);

        writer.write("ok");
    }

    // 3. HttpEntity
    @RequestMapping("/string-v3")
    public HttpEntitiy<String> stringV3(HttpEntity<String> httpEntity) {
        String messageBody = httpEntity.getBody();
        log.info("messageBody = {}", messageBody);

        return new HttpEntity<>("ok");
    }

    // 4. @RequestBody
    @ResponseBody
    @RequestMapping("/string-v4")
    public String stringV4(@RequestBody String messageBody) {
        log.info("messageBody = {}", messageBody);
        return "ok";
    }
}
```

### Json
- rest API에서 많이 쓰이는 Json 형태의 API 설계 시에 사용하는 방법.

```java
@Controller
public class RequestBody{

    private ObjectMapper objectMapper = new ObjectMapper();  // for 1 and 2

    // 1. HttpServletRequest, Response
    @RequestMapping("/json-v1")
    public void jsonV1(HttpServletRequest request, HttpServletResponse response) {
        InputStream inputStream = request.getInputStrea();
        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8)

        log.info("messageBody={}", messageBody);
        HelloData data = objectMapper.readValue(messageBody, HelloData.class);
        log.info("username={}, age={}", helloData.getUsername, helloData.getAge);

        response.getWriter().write("ok");
    }

    // 2. @RequestBody - String
    @ResponseBody
    @RequestMapping("/json-v2")
    public String jsonV2(@RequestBody String messageBody) {
        log.info("messageBody={}", messageBody);
        HelloData data = objectMapper.readValue(messageBody, HelloData.class);
        log.info("username={}, age={}", helloData.getUsername, helloData.getAge);
        return "ok";
    }

    // 3. @RequestBody - converter
    // Content-type이 application/json이어야 한다.
    @ResponseBody
    @RequestMapping("/json-v3")
    public String jsonV3(@RequestBody HelloData helloData) {
        log.info("username={}, age={}", helloData.getUsername, helloData.getAge);
        return "ok";
    }

    // 4. HttpEntity
    @ResponseBody
    @RequestMapping("/json-v4")
    public String jsonV4(HttpEntity<HelloData> httpEntity) {
        HelloData helloData = httpEntity.getBody();
        log.info("username={}, age={}", helloData.getUsername, helloData.getAge);
        return "ok";
    }

    // 5. HttpEntity - return object(data)
    @ResponseBody
    @RequestMapping("/json-v5")
    public HelloData jsonV5(HttpEntity<HelloData> httpEntity) {
        HelloData helloData = httpEntity.getBody();
        log.info("username={}, age={}", helloData.getUsername, helloData.getAge);
        return helloData;
    }
}
```